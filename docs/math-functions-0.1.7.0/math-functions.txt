-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Special functions and Chebyshev polynomials
--   
--   This library provides implementations of special mathematical
--   functions and Chebyshev polynomials. These functions are often useful
--   in statistical and numerical computing.
@package math-functions
@version 0.1.7.0


-- | Functions for summing floating point numbers more accurately than the
--   naive <a>sum</a> function and its counterparts in the <tt>vector</tt>
--   package and elsewhere.
--   
--   When used with floating point numbers, in the worst case, the
--   <a>sum</a> function accumulates numeric error at a rate proportional
--   to the number of values being summed. The algorithms in this module
--   implement different methods of /compensated summation/, which reduce
--   the accumulation of numeric error so that it either grows much more
--   slowly than the number of inputs (e.g. logarithmically), or remains
--   constant.
module Numeric.Sum

-- | A class for summation of floating point numbers.
class Summation s where sum f = f . foldl' add zero

-- | The identity for summation.
zero :: Summation s => s

-- | Add a value to a sum.
add :: Summation s => s -> Double -> s

-- | Sum a collection of values.
--   
--   Example: <tt>foo = <a>sum</a> <a>kbn</a> [1,2,3]</tt>
sum :: (Summation s, Foldable f) => (s -> Double) -> f Double -> Double

-- | <i>O(n)</i> Sum a vector of values.
sumVector :: (Vector v Double, Summation s) => (s -> Double) -> v Double -> Double

-- | Kahan-Babuška-Neumaier summation. This is a little more
--   computationally costly than plain Kahan summation, but is
--   <i>always</i> at least as accurate.
data KBNSum
KBNSum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KBNSum

-- | Return the result of a Kahan-Babuška-Neumaier sum.
kbn :: KBNSum -> Double

-- | Second-order Kahan-Babuška summation. This is more computationally
--   costly than Kahan-Babuška-Neumaier summation, running at about a third
--   the speed. Its advantage is that it can lose less precision (in
--   admittedly obscure cases).
--   
--   This method compensates for error in both the sum and the first-order
--   compensation term, hence the use of "second order" in the name.
data KB2Sum
KB2Sum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KB2Sum

-- | Return the result of an order-2 Kahan-Babuška sum.
kb2 :: KB2Sum -> Double

-- | Kahan summation. This is the least accurate of the compensated
--   summation methods. In practice, it only beats naive summation for
--   inputs with large magnitude. Kahan summation can be <i>less</i>
--   accurate than naive summation for small-magnitude inputs.
--   
--   This summation method is included for completeness. Its use is not
--   recommended. In practice, <a>KBNSum</a> is both 30% faster and more
--   accurate.
data KahanSum
KahanSum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KahanSum

-- | Return the result of a Kahan sum.
kahan :: KahanSum -> Double

-- | <i>O(n)</i> Sum a vector of values using pairwise summation.
--   
--   This approach is perhaps 10% faster than <a>KBNSum</a>, but has poorer
--   bounds on its error growth. Instead of having roughly constant error
--   regardless of the size of the input vector, in the worst case its
--   accumulated error grows with <i>O(log n)</i>.
pairwiseSum :: (Vector v Double) => v Double -> Double
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KB2Sum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KB2Sum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KB2Sum
instance Numeric.Sum.Summation Numeric.Sum.KB2Sum
instance Control.DeepSeq.NFData Numeric.Sum.KB2Sum
instance Data.Data.Data Numeric.Sum.KB2Sum
instance GHC.Show.Show Numeric.Sum.KB2Sum
instance GHC.Classes.Eq Numeric.Sum.KB2Sum
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KBNSum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KBNSum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KBNSum
instance Numeric.Sum.Summation Numeric.Sum.KBNSum
instance Control.DeepSeq.NFData Numeric.Sum.KBNSum
instance Data.Data.Data Numeric.Sum.KBNSum
instance GHC.Show.Show Numeric.Sum.KBNSum
instance GHC.Classes.Eq Numeric.Sum.KBNSum
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KahanSum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KahanSum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KahanSum
instance Numeric.Sum.Summation Numeric.Sum.KahanSum
instance Control.DeepSeq.NFData Numeric.Sum.KahanSum
instance Data.Data.Data Numeric.Sum.KahanSum
instance GHC.Show.Show Numeric.Sum.KahanSum
instance GHC.Classes.Eq Numeric.Sum.KahanSum
instance Numeric.Sum.Summation GHC.Types.Double


-- | Chebyshev polynomials.
module Numeric.Polynomial.Chebyshev

-- | Evaluate a Chebyshev polynomial of the first kind. Uses Clenshaw's
--   algorithm.
chebyshev :: (Vector v Double) => Double -> v Double -> Double

-- | Evaluate a Chebyshev polynomial of the first kind. Uses Broucke's
--   ECHEB algorithm, and his convention for coefficient handling. It treat
--   0th coefficient different so
--   
--   <pre>
--   chebyshev x [a0,a1,a2...] == chebyshevBroucke [2*a0,a1,a2...]
--   </pre>
chebyshevBroucke :: (Vector v Double) => Double -> v Double -> Double


-- | Function for evaluating polynomials using Horher's method.
module Numeric.Polynomial

-- | Evaluate polynomial using Horner's method. Coefficients starts from
--   lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1 + 2*x + 3*x^2
--   </pre>
evaluatePolynomial :: (Vector v a, Num a) => a -> v a -> a

-- | Evaluate polynomial with only even powers using Horner's method.
--   Coefficients starts from lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1 + 2*x^2 + 3*x^4
--   </pre>
evaluateEvenPolynomial :: (Vector v a, Num a) => a -> v a -> a

-- | Evaluate polynomial with only odd powers using Horner's method.
--   Coefficients starts from lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1*x + 2*x^3 + 3*x^5
--   </pre>
evaluateOddPolynomial :: (Vector v a, Num a) => a -> v a -> a
evaluatePolynomialL :: (Num a) => a -> [a] -> a
evaluateEvenPolynomialL :: (Num a) => a -> [a] -> a
evaluateOddPolynomialL :: (Num a) => a -> [a] -> a


-- | Functions for approximate comparison of floating point numbers.
--   
--   Approximate floating point comparison, based on Bruce Dawson's
--   "Comparing floating point numbers":
--   <a>http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>
module Numeric.MathFunctions.Comparison

-- | Calculate relative error of two numbers:
--   
--   <pre>
--   |a - b| / max |a| |b|
--   </pre>
--   
--   It lies in [0,1) interval for numbers with same sign and (1,2] for
--   numbers with different sign. If both arguments are zero or negative
--   zero function returns 0. If at least one argument is transfinite it
--   returns NaN
relativeError :: Double -> Double -> Double

-- | Check that relative error between two numbers <tt>a</tt> and
--   <tt>b</tt>. If <a>relativeError</a> returns NaN it returns
--   <tt>False</tt>.
eqRelErr :: Double -> Double -> Double -> Bool

-- | Add N ULPs (units of least precision) to <tt>Double</tt> number.
addUlps :: Int -> Double -> Double

-- | Measure distance between two <tt>Double</tt>s in ULPs (units of least
--   precision).
ulpDistance :: Double -> Double -> Word64

-- | Compare two <a>Double</a> values for approximate equality, using
--   Dawson's method.
--   
--   The required accuracy is specified in ULPs (units of least precision).
--   If the two numbers differ by the given number of ULPs or less, this
--   function returns <tt>True</tt>.
within :: Int -> Double -> Double -> Bool


-- | Constant values common to much numeric code.
module Numeric.MathFunctions.Constants

-- | The smallest <a>Double</a> ε such that 1 + ε ≠ 1.
m_epsilon :: Double

-- | A very large number.
m_huge :: Double
m_tiny :: Double

-- | The largest <a>Int</a> <i>x</i> such that 2**(<i>x</i>-1) is
--   approximately representable as a <a>Double</a>.
m_max_exp :: Int

-- | Positive infinity.
m_pos_inf :: Double

-- | Negative infinity.
m_neg_inf :: Double

-- | Not a number.
m_NaN :: Double

-- | <pre>
--   1 / sqrt 2
--   </pre>
m_1_sqrt_2 :: Double

-- | <pre>
--   2 / sqrt pi
--   </pre>
m_2_sqrt_pi :: Double

-- | <pre>
--   log(sqrt((2*pi))
--   </pre>
m_ln_sqrt_2_pi :: Double

-- | <pre>
--   sqrt 2
--   </pre>
m_sqrt_2 :: Double

-- | <pre>
--   sqrt (2 * pi)
--   </pre>
m_sqrt_2_pi :: Double

-- | Euler–Mascheroni constant (γ = 0.57721...)
m_eulerMascheroni :: Double


-- | Special functions and factorials.
module Numeric.SpecFunctions

-- | Error function.
--   
--   <pre>
--   erf -∞ = -1
--   erf  0 =  0
--   erf +∞ =  1
--   </pre>
erf :: Double -> Double

-- | Complementary error function.
--   
--   <pre>
--   erfc -∞ = 2
--   erfc  0 = 1
--   errc +∞ = 0
--   </pre>
erfc :: Double -> Double

-- | Inverse of <a>erf</a>.
invErf :: Double -> Double

-- | Inverse of <a>erfc</a>.
invErfc :: Double -> Double

-- | Compute the logarithm of the gamma function Γ(<i>x</i>). Uses
--   Algorithm AS 245 by Macleod.
--   
--   Gives an accuracy of 10-12 significant decimal digits, except for
--   small regions around <i>x</i> = 1 and <i>x</i> = 2, where the function
--   goes to zero. For greater accuracy, use <a>logGammaL</a>.
--   
--   Returns ∞ if the input is outside of the range (0 &lt; <i>x</i> ≤
--   1e305).
logGamma :: Double -> Double

-- | Compute the logarithm of the gamma function, Γ(<i>x</i>). Uses a
--   Lanczos approximation.
--   
--   This function is slower than <a>logGamma</a>, but gives 14 or more
--   significant decimal digits of accuracy, except around <i>x</i> = 1 and
--   <i>x</i> = 2, where the function goes to zero.
--   
--   Returns ∞ if the input is outside of the range (0 &lt; <i>x</i> ≤
--   1e305).
logGammaL :: Double -> Double

-- | Compute the normalized lower incomplete gamma function
--   γ(<i>s</i>,<i>x</i>). Normalization means that γ(<i>s</i>,∞)=1. Uses
--   Algorithm AS 239 by Shea.
incompleteGamma :: Double -> Double -> Double

-- | Inverse incomplete gamma function. It's approximately inverse of
--   <a>incompleteGamma</a> for the same <i>s</i>. So following equality
--   approximately holds:
--   
--   <pre>
--   invIncompleteGamma s . incompleteGamma s = id
--   </pre>
invIncompleteGamma :: Double -> Double -> Double

-- | Compute ψ0(<i>x</i>), the first logarithmic derivative of the gamma
--   function. Uses Algorithm AS 103 by Bernardo, based on Minka's C
--   implementation.
digamma :: Double -> Double

-- | Compute the natural logarithm of the beta function.
logBeta :: Double -> Double -> Double

-- | Regularized incomplete beta function. Uses algorithm AS63 by Majumder
--   and Bhattachrjee and quadrature approximation for large <i>p</i> and
--   <i>q</i>.
incompleteBeta :: Double -> Double -> Double -> Double

-- | Regularized incomplete beta function. Same as <a>incompleteBeta</a>
--   but also takes logarithm of beta function as parameter.
incompleteBeta_ :: Double -> Double -> Double -> Double -> Double

-- | Compute inverse of regularized incomplete beta function. Uses initial
--   approximation from AS109, AS64 and Halley method to solve equation.
invIncompleteBeta :: Double -> Double -> Double -> Double

-- | Compute sinc function <tt>sin(x)/x</tt>
sinc :: Double -> Double

-- | Compute the natural logarithm of 1 + <tt>x</tt>. This is accurate even
--   for values of <tt>x</tt> near zero, where use of <tt>log(1+x)</tt>
--   would lose precision.
log1p :: Double -> Double

-- | <i>O(log n)</i> Compute the logarithm in base 2 of the given value.
log2 :: Int -> Int

-- | Compute the factorial function <i>n</i>!. Returns +∞ if the input is
--   above 170 (above which the result cannot be represented by a 64-bit
--   <a>Double</a>).
factorial :: Int -> Double

-- | Compute the natural logarithm of the factorial function. Gives 16
--   decimal digits of precision.
logFactorial :: Integral a => a -> Double

-- | Calculate the error term of the Stirling approximation. This is only
--   defined for non-negative values.
--   
--   <pre>
--   stirlingError @n@ = @log(n!) - log(sqrt(2*pi*n)*(n/e)^n)
--   </pre>
stirlingError :: Double -> Double

-- | Compute the binomial coefficient <i>n</i> <tt>`<a>choose</a>`</tt>
--   <i>k</i>. For values of <i>k</i> &gt; 50, this uses an approximation
--   for performance reasons. The approximation is accurate to 12 decimal
--   places in the worst case
--   
--   Example:
--   
--   <pre>
--   7 `choose` 3 == 35
--   </pre>
choose :: Int -> Int -> Double

-- | Compute logarithm of the binomial coefficient.
logChoose :: Int -> Int -> Double


-- | Less common mathematical functions.
module Numeric.SpecFunctions.Extra

-- | Evaluate the deviance term <tt>x log(x/np) + np - x</tt>.
bd0 :: Double -> Double -> Double

-- | Calculate binomial coefficient using exact formula
chooseExact :: Int -> Int -> Double

-- | Quickly compute the natural logarithm of <i>n</i>
--   <tt><a>choose</a></tt> <i>k</i>, with no checking.
--   
--   Less numerically stable:
--   
--   <pre>
--   exp $ lg (n+1) - lg (k+1) - lg (n-k+1)
--     where lg = logGamma . fromIntegral
--   </pre>
logChooseFast :: Double -> Double -> Double
