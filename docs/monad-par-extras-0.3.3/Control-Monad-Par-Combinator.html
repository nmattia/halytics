<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Par.Combinator</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Par-Combinator.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">monad-par-extras-0.3.3: Combinators and extra features for Par monads</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Monad.Par.Combinator</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A collection of useful parallel combinators based on top of a <code>Par</code> monad.</p><p>In particular, this module provides higher order functions for
     traversing data structures in parallel.  </p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:parMap">parMap</a> :: (<a href="../base-4.8.2.0/Data-Traversable.html#t:Traversable">Traversable</a> t, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; (a -&gt; b) -&gt; t a -&gt; p (t b)</li><li class="src short"><a href="#v:parMapM">parMapM</a> :: (<a href="../base-4.8.2.0/Data-Traversable.html#t:Traversable">Traversable</a> t, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; (a -&gt; p b) -&gt; t a -&gt; p (t b)</li><li class="src short"><a href="#v:parMapReduceRangeThresh">parMapReduceRangeThresh</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a> -&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p a) -&gt; (a -&gt; a -&gt; p a) -&gt; a -&gt; p a</li><li class="src short"><a href="#v:parMapReduceRange">parMapReduceRange</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a> -&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p a) -&gt; (a -&gt; a -&gt; p a) -&gt; a -&gt; p a</li><li class="src short"><span class="keyword">data</span> <a href="#t:InclusiveRange">InclusiveRange</a> = <a href="#v:InclusiveRange">InclusiveRange</a> <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:parFor">parFor</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p =&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a> -&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p ()) -&gt; p ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:parMap" class="def">parMap</a> :: (<a href="../base-4.8.2.0/Data-Traversable.html#t:Traversable">Traversable</a> t, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; (a -&gt; b) -&gt; t a -&gt; p (t b)</p><div class="doc"><p>Applies the given function to each element of a data structure
 in parallel (fully evaluating the results), and returns a new data
 structure containing the results.</p><pre>parMap f xs = mapM (spawnP . f) xs &gt;&gt;= mapM get</pre><p><code>parMap</code> is commonly used for lists, where it has this specialised type:</p><pre>parMap :: NFData b =&gt; (a -&gt; b) -&gt; [a] -&gt; Par [b]</pre></div></div><div class="top"><p class="src"><a name="v:parMapM" class="def">parMapM</a> :: (<a href="../base-4.8.2.0/Data-Traversable.html#t:Traversable">Traversable</a> t, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; (a -&gt; p b) -&gt; t a -&gt; p (t b)</p><div class="doc"><p>Like <code><a href="Control-Monad-Par-Combinator.html#v:parMap">parMap</a></code>, but the function is a <code>Par</code> monad operation.</p><pre>parMapM f xs = mapM (spawn . f) xs &gt;&gt;= mapM get</pre></div></div><div class="top"><p class="src"><a name="v:parMapReduceRangeThresh" class="def">parMapReduceRangeThresh</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>threshold</p></td></tr><tr><td class="src">-&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a></td><td class="doc"><p>range over which to calculate</p></td></tr><tr><td class="src">-&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p a)</td><td class="doc"><p>compute one result</p></td></tr><tr><td class="src">-&gt; (a -&gt; a -&gt; p a)</td><td class="doc"><p>combine two results (associative)</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial result</p></td></tr><tr><td class="src">-&gt; p a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Computes a binary map/reduce over a finite range.  The range is
 recursively split into two, the result for each half is computed in
 parallel, and then the two results are combined.  When the range
 reaches the threshold size, the remaining elements of the range are
 computed sequentially.</p><p>For example, the following is a parallel implementation of</p><pre> foldl (+) 0 (map (^2) [1..10^6])</pre><pre>parMapReduceRangeThresh 100 (InclusiveRange 1 (10^6))
       (\x -&gt; return (x^2))
       (\x y -&gt; return (x+y))
       0</pre></div></div><div class="top"><p class="src"><a name="v:parMapReduceRange" class="def">parMapReduceRange</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p) =&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a> -&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p a) -&gt; (a -&gt; a -&gt; p a) -&gt; a -&gt; p a</p><div class="doc"><p>&quot;Auto-partitioning&quot; version of <code><a href="Control-Monad-Par-Combinator.html#v:parMapReduceRangeThresh">parMapReduceRangeThresh</a></code> that chooses the threshold based on
    the size of the range and the number of processors..</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:InclusiveRange" class="def">InclusiveRange</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:InclusiveRange" class="def">InclusiveRange</a> <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:parFor" class="def">parFor</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:ParFuture">ParFuture</a> iv p =&gt; <a href="Control-Monad-Par-Combinator.html#t:InclusiveRange">InclusiveRange</a> -&gt; (<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; p ()) -&gt; p ()</p><div class="doc"><p>Parallel for-loop over an inclusive range.  Semantically equivalent
 to</p><pre>parFor (InclusiveRange n m) f = forM_ [n..m] f</pre><p>except that the implementation will split the work into an
 unspecified number of subtasks in an attempt to gain parallelism.
 The exact number of subtasks is chosen at runtime, and is probably
 a small multiple of the available number of processors.</p><p>Strictly speaking the semantics of <code><a href="Control-Monad-Par-Combinator.html#v:parFor">parFor</a></code> depends on the
 number of processors, and its behaviour is therefore not
 deterministic.  However, a good rule of thumb is to not have any
 interdependencies between the elements; if this rule is followed
 then <code>parFor</code> has deterministic semantics.  One easy way to follow
 this rule is to only use <code><a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#v:put">put</a></code> or <code><a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#v:put_">put_</a></code> in <code>f</code>, never <code><a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#v:get">get</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>