<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.List.Split</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-List-Split.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">split-0.2.3.1: Combinator library for splitting lists.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Brent Yorgey, Louis Wasserman 2008-2012</td></tr><tr><th>License</th><td>BSD-style (see LICENSE)</td></tr><tr><th>Maintainer</th><td>Brent Yorgey &lt;byorgey@gmail.com&gt;</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Portability</th><td>Haskell 2010</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.List.Split</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Getting started</a></li><li><a href="#g:2">Convenience functions</a></li><li><a href="#g:3">Other splitting methods</a></li><li><a href="#g:4">Splitting combinators</a><ul><li><a href="#g:5">Basic strategies</a></li><li><a href="#g:6">Strategy transformers</a></li><li><a href="#g:7">Derived combinators</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <a href="Data-List-Split.html">Data.List.Split</a> module contains a wide range of strategies
 for splitting lists with respect to some sort of delimiter, mostly
 implemented through a unified combinator interface.  The goal is to
 be flexible yet simple.  See below for usage, examples, and
 detailed documentation of all exported functions.  If you want to
 learn about the implementation, see <a href="Data-List-Split-Internals.html">Data.List.Split.Internals</a>.</p><p>A darcs repository containing the source (including a module with
 over 40 QuickCheck properties) can be found at
 <a href="http://hub.darcs.net/byorgey/split">http://hub.darcs.net/byorgey/split</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:splitOn">splitOn</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:splitOneOf">splitOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:splitWhen">splitWhen</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:endBy">endBy</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:endByOneOf">endByOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:wordsBy">wordsBy</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:linesBy">linesBy</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; [e] -&gt; [[e]]</li><li class="src short"><a href="#v:splitPlaces">splitPlaces</a> :: <a href="../base-4.8.2.0/Prelude.html#t:Integral">Integral</a> a =&gt; [a] -&gt; [e] -&gt; [[e]]</li><li class="src short"><a href="#v:splitPlacesBlanks">splitPlacesBlanks</a> :: <a href="../base-4.8.2.0/Prelude.html#t:Integral">Integral</a> a =&gt; [a] -&gt; [e] -&gt; [[e]]</li><li class="src short"><a href="#v:chop">chop</a> :: ([a] -&gt; (b, [a])) -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:divvy">divvy</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><span class="keyword">data</span> <a href="#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:defaultSplitter">defaultSplitter</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:split">split</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:oneOf">oneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:onSublist">onSublist</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:whenElt">whenElt</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:dropDelims">dropDelims</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:keepDelimsL">keepDelimsL</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:keepDelimsR">keepDelimsR</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:condense">condense</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:dropInitBlank">dropInitBlank</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:dropFinalBlank">dropFinalBlank</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:dropInnerBlanks">dropInnerBlanks</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:dropBlanks">dropBlanks</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:startsWith">startsWith</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:startsWithOneOf">startsWithOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:endsWith">endsWith</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li><li class="src short"><a href="#v:endsWithOneOf">endsWithOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</li></ul></div><div id="interface"><h1 id="g:1">Getting started</h1><div class="doc"><p>To get started, you should take a look at the functions <code><a href="Data-List-Split.html#v:splitOn">splitOn</a></code>,
 <code><a href="Data-List-Split.html#v:splitOneOf">splitOneOf</a></code>, <code><a href="Data-List-Split.html#v:splitWhen">splitWhen</a></code>, <code><a href="Data-List-Split.html#v:endBy">endBy</a></code>, <code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code>, <code><a href="Data-List-Split.html#v:splitPlaces">splitPlaces</a></code>,
 and other functions listed in the next two sections.  These
 functions implement various common splitting operations, and one of
 them will probably do the job 90% of the time.  For example:</p><pre>&gt; splitOn &quot;x&quot; &quot;axbxc&quot;
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]

&gt; splitOn &quot;x&quot; &quot;axbxcx&quot;
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;]

&gt; endBy &quot;;&quot; &quot;foo;bar;baz;&quot;
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]

&gt; splitWhen (&lt;0) [1,3,-4,5,7,-9,0,2]
[[1,3],[5,7],[0,2]]

&gt; splitOneOf &quot;;.,&quot; &quot;foo,bar;baz.glurk&quot;
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;glurk&quot;]

&gt; chunksOf 3 ['a'..'z']
[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqr&quot;,&quot;stu&quot;,&quot;vwx&quot;,&quot;yz&quot;]</pre><p>If you want more flexibility, however, you can use the combinator
 library in terms of which these functions are defined.  For more
 information, see the section labeled &quot;Splitting Combinators&quot;.</p><p>The goal of this library is to be flexible yet simple.  It does not
 implement any particularly sophisticated list-splitting methods,
 nor is it tuned for speed.  If you find yourself wanting something
 more complicated or optimized, it probably means you should use a
 real parsing or regular expression library.</p></div><h1 id="g:2">Convenience functions</h1><div class="doc"><p>These functions implement some common splitting strategies.  Note
 that all of the functions in this section drop delimiters from the
 final output, since that is a more common use case.  If you wish to
 keep the delimiters somehow, see the &quot;Splitting Combinators&quot;
 section.</p></div><div class="top"><p class="src"><a name="v:splitOn" class="def">splitOn</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split on the given sublist.  Equivalent to <code><code><a href="Data-List-Split.html#v:split">split</a></code>
   . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code> . <code><a href="Data-List-Split.html#v:onSublist">onSublist</a></code></code>.  For example:</p><pre>splitOn &quot;..&quot; &quot;a..b...c....d..&quot; == [&quot;a&quot;,&quot;b&quot;,&quot;.c&quot;,&quot;&quot;,&quot;d&quot;,&quot;&quot;]</pre><p>In some parsing combinator frameworks this is also known as
   <code>sepBy</code>.</p><p>Note that this is the right inverse of the <code><a href="../base-4.8.2.0/Data-List.html#v:intercalate">intercalate</a></code> function
   from <a href="../base-4.8.2.0/Data-List.html">Data.List</a>, that is,</p><pre>intercalate x . splitOn x === id</pre><p><code><code><a href="Data-List-Split.html#v:splitOn">splitOn</a></code> x . <code><a href="../base-4.8.2.0/Data-List.html#v:intercalate">intercalate</a></code> x</code> is the identity on
   certain lists, but it is tricky to state the precise conditions
   under which this holds.  (For example, it is not enough to say
   that <code>x</code> does not occur in any elements of the input list.
   Working out why is left as an exercise for the reader.)</p></div></div><div class="top"><p class="src"><a name="v:splitOneOf" class="def">splitOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split on any of the given elements.  Equivalent to <code><code><a href="Data-List-Split.html#v:split">split</a></code>
   . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code> . <code><a href="Data-List-Split.html#v:oneOf">oneOf</a></code></code>.  For example:</p><pre>splitOneOf &quot;;.,&quot; &quot;foo,bar;baz.glurk&quot; == [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;glurk&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:splitWhen" class="def">splitWhen</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split on elements satisfying the given predicate.  Equivalent to
   <code><code><a href="Data-List-Split.html#v:split">split</a></code> . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code> . <code><a href="Data-List-Split.html#v:whenElt">whenElt</a></code></code>.  For example:</p><pre>splitWhen (&lt;0) [1,3,-4,5,7,-9,0,2] == [[1,3],[5,7],[0,2]]</pre></div></div><div class="top"><p class="src"><a name="v:endBy" class="def">endBy</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split into chunks terminated by the given subsequence.
   Equivalent to <code><code><a href="Data-List-Split.html#v:split">split</a></code> . <code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code>
   . <code><a href="Data-List-Split.html#v:onSublist">onSublist</a></code></code>.  For example:</p><pre>endBy &quot;;&quot; &quot;foo;bar;baz;&quot; == [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</pre><p>Note also that the <code><a href="../base-4.8.2.0/GHC-OldList.html#v:lines">lines</a></code> function from <a href="../base-4.8.2.0/Data-List.html">Data.List</a> is equivalent
   to <code><code><a href="Data-List-Split.html#v:endBy">endBy</a></code> &quot;\n&quot;</code>.</p></div></div><div class="top"><p class="src"><a name="v:endByOneOf" class="def">endByOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split into chunks terminated by one of the given elements.
   Equivalent to <code><code><a href="Data-List-Split.html#v:split">split</a></code> . <code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code>
   . <code><a href="Data-List-Split.html#v:oneOf">oneOf</a></code></code>. For example:</p><pre>endByOneOf &quot;;,&quot; &quot;foo;bar,baz;&quot; == [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:wordsBy" class="def">wordsBy</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split into &quot;words&quot;, with word boundaries indicated by the given
   predicate.  Satisfies <code><code><a href="../base-4.8.2.0/Data-List.html#v:words">words</a></code> === wordsBy
   <code><a href="../base-4.8.2.0/Data-Char.html#v:isSpace">isSpace</a></code></code>; equivalent to <code><code><a href="Data-List-Split.html#v:split">split</a></code> . <code><a href="Data-List-Split.html#v:dropBlanks">dropBlanks</a></code>
   . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code> . <code><a href="Data-List-Split.html#v:whenElt">whenElt</a></code></code>.  For example:</p><pre>wordsBy (=='x') &quot;dogxxxcatxbirdxx&quot; == [&quot;dog&quot;,&quot;cat&quot;,&quot;bird&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:linesBy" class="def">linesBy</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split into &quot;lines&quot;, with line boundaries indicated by the given
   predicate. Satisfies <code><code><a href="../base-4.8.2.0/GHC-OldList.html#v:lines">lines</a></code> === linesBy (=='\n')</code>; equivalent to
   <code><code><a href="Data-List-Split.html#v:split">split</a></code> . <code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:dropDelims">dropDelims</a></code> . <code><a href="Data-List-Split.html#v:whenElt">whenElt</a></code></code>.  For example:</p><pre>linesBy (=='x') &quot;dogxxxcatxbirdxx&quot; == [&quot;dog&quot;,&quot;&quot;,&quot;&quot;,&quot;cat&quot;,&quot;bird&quot;,&quot;&quot;]</pre></div></div><h1 id="g:3">Other splitting methods</h1><div class="doc"><p>Other useful splitting methods which are not implemented using the
 combinator framework.</p></div><div class="top"><p class="src"><a name="v:chunksOf" class="def">chunksOf</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; [e] -&gt; [[e]]</p><div class="doc"><p><code><code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code> n</code> splits a list into length-n pieces.  The last
   piece will be shorter if <code>n</code> does not evenly divide the length of
   the list.  If <code>n &lt;= 0</code>, <code><code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code> n l</code> returns an infinite list
   of empty lists.  For example:</p><p>Note that <code><code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code> n []</code> is <code>[]</code>, not <code>[[]]</code>.  This is
   intentional, and is consistent with a recursive definition of
   <code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code>; it satisfies the property that</p><pre>chunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)</pre><p>whenever <code>n</code> evenly divides the length of <code>xs</code>.</p></div></div><div class="top"><p class="src"><a name="v:splitPlaces" class="def">splitPlaces</a> :: <a href="../base-4.8.2.0/Prelude.html#t:Integral">Integral</a> a =&gt; [a] -&gt; [e] -&gt; [[e]]</p><div class="doc"><p>Split a list into chunks of the given lengths. For example:</p><pre>splitPlaces [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]
splitPlaces [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]
splitPlaces [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]</pre><p>If the input list is longer than the total of the given lengths,
   then the remaining elements are dropped. If the list is shorter
   than the total of the given lengths, then the result may contain
   fewer chunks than requested, and the last chunk may be shorter
   than requested.</p></div></div><div class="top"><p class="src"><a name="v:splitPlacesBlanks" class="def">splitPlacesBlanks</a> :: <a href="../base-4.8.2.0/Prelude.html#t:Integral">Integral</a> a =&gt; [a] -&gt; [e] -&gt; [[e]]</p><div class="doc"><p>Split a list into chunks of the given lengths. Unlike
   <code><a href="Data-List-Split.html#v:splitPlaces">splitPlaces</a></code>, the output list will always be the same length as
   the first input argument. If the input list is longer than the
   total of the given lengths, then the remaining elements are
   dropped. If the list is shorter than the total of the given
   lengths, then the last several chunks will be shorter than
   requested or empty. For example:</p><pre>splitPlacesBlanks [2,3,4] [1..20] == [[1,2],[3,4,5],[6,7,8,9]]
splitPlacesBlanks [4,9] [1..10] == [[1,2,3,4],[5,6,7,8,9,10]]
splitPlacesBlanks [4,9,3] [1..10] == [[1,2,3,4],[5,6,7,8,9,10],[]]</pre><p>Notice the empty list in the output of the third example, which
   differs from the behavior of <code><a href="Data-List-Split.html#v:splitPlaces">splitPlaces</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:chop" class="def">chop</a> :: ([a] -&gt; (b, [a])) -&gt; [a] -&gt; [b]</p><div class="doc"><p>A useful recursion pattern for processing a list to produce a new
   list, often used for &quot;chopping&quot; up the input list.  Typically
   chop is called with some function that will consume an initial
   prefix of the list and produce a value and the rest of the list.</p><p>For example, many common Prelude functions can be implemented in
   terms of <code>chop</code>:</p><pre>group :: (Eq a) =&gt; [a] -&gt; [[a]]
group = chop (\ xs@(x:_) -&gt; span (==x) xs)

words :: String -&gt; [String]
words = filter (not . null) . chop (span (not . isSpace) . dropWhile isSpace)</pre></div></div><div class="top"><p class="src"><a name="v:divvy" class="def">divvy</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Divides up an input list into a set of sublists, according to <code>n</code> and <code>m</code>
   input specifications you provide. Each sublist will have <code>n</code> items, and the
   start of each sublist will be offset by <code>m</code> items from the previous one.</p><pre>divvy 5 5 [1..20] == [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]</pre><p>In the case where a source list's trailing elements do no fill an entire
   sublist, those trailing elements will be dropped.</p><pre>divvy 5 2 [1..10] == [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9]]</pre><p>As an example, you can generate a moving average over a list of prices:</p><pre>type Prices = [Float]
type AveragePrices = [Float]

average :: [Float] -&gt; Float
average xs = sum xs / (fromIntegral $ length xs)

simpleMovingAverage :: Prices -&gt; AveragePrices
simpleMovingAverage priceList =
  map average divvyedPrices
    where divvyedPrices = divvy 20 1 priceList</pre></div></div><h1 id="g:4">Splitting combinators</h1><div class="doc"><p>The core of the library is the <code><a href="Data-List-Split.html#t:Splitter">Splitter</a></code> type, which represents a
 particular list-splitting strategy.  All of the combinators revolve
 around constructing or transforming <code><a href="Data-List-Split.html#t:Splitter">Splitter</a></code> objects; once a
 suitable <code><a href="Data-List-Split.html#t:Splitter">Splitter</a></code> has been created, it can be run with the
 <code><a href="Data-List-Split.html#v:split">split</a></code> function.  For example:</p><pre>&gt; split (dropBlanks . condense $ whenElt (&lt;0)) [1,2,4,-5,-6,4,9,-19,-30]
[[1,2,4],[-5,-6],[4,9],[-19,-30]]</pre></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Splitter" class="def">Splitter</a> a</p><div class="doc"><p>A splitting strategy.</p></div></div><div class="top"><p class="src"><a name="v:defaultSplitter" class="def">defaultSplitter</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>The default splitting strategy: keep delimiters in the output
   as separate chunks, don't condense multiple consecutive
   delimiters into one, keep initial and final blank chunks.
   Default delimiter is the constantly false predicate.</p><p>Note that <code><a href="Data-List-Split.html#v:defaultSplitter">defaultSplitter</a></code> should normally not be used; use
   <code><a href="Data-List-Split.html#v:oneOf">oneOf</a></code>, <code><a href="Data-List-Split.html#v:onSublist">onSublist</a></code>, or <code><a href="Data-List-Split.html#v:whenElt">whenElt</a></code> instead, which are the same as
   the <code><a href="Data-List-Split.html#v:defaultSplitter">defaultSplitter</a></code> with just the delimiter overridden.</p><p>The <code><a href="Data-List-Split.html#v:defaultSplitter">defaultSplitter</a></code> strategy with any delimiter gives a
   maximally information-preserving splitting strategy, in the sense
   that (a) taking the <code><a href="../base-4.8.2.0/Data-Foldable.html#v:concat">concat</a></code> of the output yields the original
   list, and (b) given only the output list, we can reconstruct a
   <code><a href="Data-List-Split.html#t:Splitter">Splitter</a></code> which would produce the same output list again given
   the original input list.  This default strategy can be overridden
   to allow discarding various sorts of information.</p></div></div><div class="top"><p class="src"><a name="v:split" class="def">split</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; [a] -&gt; [[a]]</p><div class="doc"><p>Split a list according to the given splitting strategy.  This is
   how to &quot;run&quot; a <code><a href="Data-List-Split.html#t:Splitter">Splitter</a></code> that has been built using the other
   combinators.</p></div></div><h2 id="g:5">Basic strategies</h2><div class="doc"><p>All these basic strategies have the same parameters as the
 <code><a href="Data-List-Split.html#v:defaultSplitter">defaultSplitter</a></code> except for the delimiter.</p></div><div class="top"><p class="src"><a name="v:oneOf" class="def">oneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>A splitting strategy that splits on any one of the given
   elements.  For example:</p><pre>split (oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aa&quot;,&quot;z&quot;,&quot;b&quot;,&quot;x&quot;,&quot;&quot;,&quot;y&quot;,&quot;&quot;,&quot;z&quot;,&quot;c&quot;,&quot;x&quot;,&quot;d&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:onSublist" class="def">onSublist</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>A splitting strategy that splits on the given list, when it is
   encountered as an exact subsequence.  For example:</p><pre>split (onSublist &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aazb&quot;,&quot;xyz&quot;,&quot;cxd&quot;]</pre><p>Note that splitting on the empty list is a special case, which
   splits just before every element of the list being split.  For example:</p><pre>split (onSublist &quot;&quot;) &quot;abc&quot; == [&quot;&quot;,&quot;&quot;,&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;,&quot;c&quot;]
split (dropDelims . dropBlanks $ onSublist &quot;&quot;) &quot;abc&quot; == [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</pre><p>However, if you want to break a list into singleton elements like
   this, you are better off using <code><code><a href="Data-List-Split.html#v:chunksOf">chunksOf</a></code> 1</code>, or better yet,
   <code><code><a href="../base-4.8.2.0/GHC-OldList.html#v:map">map</a></code> (:[])</code>.</p></div></div><div class="top"><p class="src"><a name="v:whenElt" class="def">whenElt</a> :: (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>A splitting strategy that splits on any elements that satisfy the
   given predicate.  For example:</p><pre>split (whenElt (&lt;0)) [2,4,-3,6,-9,1] == [[2,4],[-3],[6],[-9],[1]]</pre></div></div><h2 id="g:6">Strategy transformers</h2><div class="doc"><p>Functions for altering splitting strategy parameters.</p></div><div class="top"><p class="src"><a name="v:dropDelims" class="def">dropDelims</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Drop delimiters from the output (the default is to keep
   them). For example,</p><pre>split (oneOf &quot;:&quot;) &quot;a:b:c&quot; == [&quot;a&quot;, &quot;:&quot;, &quot;b&quot;, &quot;:&quot;, &quot;c&quot;]
split (dropDelims $ oneOf &quot;:&quot;) &quot;a:b:c&quot; == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:keepDelimsL" class="def">keepDelimsL</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Keep delimiters in the output by prepending them to adjacent
   chunks.  For example:</p><pre>split (keepDelimsL $ oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aa&quot;,&quot;zb&quot;,&quot;x&quot;,&quot;y&quot;,&quot;zc&quot;,&quot;xd&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:keepDelimsR" class="def">keepDelimsR</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Keep delimiters in the output by appending them to adjacent
   chunks. For example:</p><pre>split (keepDelimsR $ oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aaz&quot;,&quot;bx&quot;,&quot;y&quot;,&quot;z&quot;,&quot;cx&quot;,&quot;d&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:condense" class="def">condense</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Condense multiple consecutive delimiters into one.  For example:</p><pre>split (condense $ oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aa&quot;,&quot;z&quot;,&quot;b&quot;,&quot;xyz&quot;,&quot;c&quot;,&quot;x&quot;,&quot;d&quot;]
split (dropDelims $ oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aa&quot;,&quot;b&quot;,&quot;&quot;,&quot;&quot;,&quot;c&quot;,&quot;d&quot;]
split (condense . dropDelims $ oneOf &quot;xyz&quot;) &quot;aazbxyzcxd&quot; == [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:dropInitBlank" class="def">dropInitBlank</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Don't generate a blank chunk if there is a delimiter at the
   beginning.  For example:</p><pre>split (oneOf &quot;:&quot;) &quot;:a:b&quot; == [&quot;&quot;,&quot;:&quot;,&quot;a&quot;,&quot;:&quot;,&quot;b&quot;]
split (dropInitBlank $ oneOf &quot;:&quot;) &quot;:a:b&quot; == [&quot;:&quot;,&quot;a&quot;,&quot;:&quot;,&quot;b&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:dropFinalBlank" class="def">dropFinalBlank</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Don't generate a blank chunk if there is a delimiter at the end.
   For example:</p><pre>split (oneOf &quot;:&quot;) &quot;a:b:&quot; == [&quot;a&quot;,&quot;:&quot;,&quot;b&quot;,&quot;:&quot;,&quot;&quot;]
split (dropFinalBlank $ oneOf &quot;:&quot;) &quot;a:b:&quot; == [&quot;a&quot;,&quot;:&quot;,&quot;b&quot;,&quot;:&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:dropInnerBlanks" class="def">dropInnerBlanks</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Don't generate blank chunks between consecutive delimiters.
   For example:</p><pre>split (oneOf &quot;:&quot;) &quot;::b:::a&quot; == [&quot;&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;b&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;a&quot;]
split (dropInnerBlanks $ oneOf &quot;:&quot;) &quot;::b:::a&quot; == [&quot;&quot;, &quot;:&quot;,&quot;:&quot;,&quot;b&quot;,&quot;:&quot;,&quot;:&quot;,&quot;:&quot;,&quot;a&quot;]</pre></div></div><h2 id="g:7">Derived combinators</h2><div class="doc"><p>Combinators which can be defined in terms of other combinators, but
 are provided for convenience.</p></div><div class="top"><p class="src"><a name="v:dropBlanks" class="def">dropBlanks</a> :: <a href="Data-List-Split.html#t:Splitter">Splitter</a> a -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Drop all blank chunks from the output, and condense consecutive
   delimiters into one.  Equivalent to <code><code><a href="Data-List-Split.html#v:dropInitBlank">dropInitBlank</a></code>
   . <code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:condense">condense</a></code></code>.  For example:</p><pre>split (oneOf &quot;:&quot;) &quot;::b:::a&quot; == [&quot;&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;b&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;&quot;,&quot;:&quot;,&quot;a&quot;]
split (dropBlanks $ oneOf &quot;:&quot;) &quot;::b:::a&quot; == [&quot;::&quot;,&quot;b&quot;,&quot;:::&quot;,&quot;a&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:startsWith" class="def">startsWith</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Make a strategy that splits a list into chunks that all start
   with the given subsequence (except possibly the first).
   Equivalent to <code><code><a href="Data-List-Split.html#v:dropInitBlank">dropInitBlank</a></code> . <code><a href="Data-List-Split.html#v:keepDelimsL">keepDelimsL</a></code> . <code><a href="Data-List-Split.html#v:onSublist">onSublist</a></code></code>.
   For example:</p><pre>split (startsWith &quot;app&quot;) &quot;applyapplicativeapplaudapproachapple&quot; == [&quot;apply&quot;,&quot;applicative&quot;,&quot;applaud&quot;,&quot;approach&quot;,&quot;apple&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:startsWithOneOf" class="def">startsWithOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Make a strategy that splits a list into chunks that all start
   with one of the given elements (except possibly the first).
   Equivalent to <code><code><a href="Data-List-Split.html#v:dropInitBlank">dropInitBlank</a></code> . <code><a href="Data-List-Split.html#v:keepDelimsL">keepDelimsL</a></code> . <code><a href="Data-List-Split.html#v:oneOf">oneOf</a></code></code>.  For
   example:</p><pre>split (startsWithOneOf ['A'..'Z']) &quot;ACamelCaseIdentifier&quot; == [&quot;A&quot;,&quot;Camel&quot;,&quot;Case&quot;,&quot;Identifier&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:endsWith" class="def">endsWith</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Make a strategy that splits a list into chunks that all end with
   the given subsequence, except possibly the last.  Equivalent to
   <code><code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:keepDelimsR">keepDelimsR</a></code> . <code><a href="Data-List-Split.html#v:onSublist">onSublist</a></code></code>.  For example:</p><pre>split (endsWith &quot;ly&quot;) &quot;happilyslowlygnarlylily&quot; == [&quot;happily&quot;,&quot;slowly&quot;,&quot;gnarly&quot;,&quot;lily&quot;]</pre></div></div><div class="top"><p class="src"><a name="v:endsWithOneOf" class="def">endsWithOneOf</a> :: <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="Data-List-Split.html#t:Splitter">Splitter</a> a</p><div class="doc"><p>Make a strategy that splits a list into chunks that all end with
   one of the given elements, except possibly the last.  Equivalent
   to <code><code><a href="Data-List-Split.html#v:dropFinalBlank">dropFinalBlank</a></code> . <code><a href="Data-List-Split.html#v:keepDelimsR">keepDelimsR</a></code> . <code><a href="Data-List-Split.html#v:oneOf">oneOf</a></code></code>.  For example:</p><pre>split (condense $ endsWithOneOf &quot;.,?! &quot;) &quot;Hi, there!  How are you?&quot; == [&quot;Hi, &quot;,&quot;there!  &quot;,&quot;How &quot;,&quot;are &quot;,&quot;you?&quot;]</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>